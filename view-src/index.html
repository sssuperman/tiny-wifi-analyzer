<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wifi-analyzer</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        font-family: ui-sans-serif, system-ui, sans-serif;
      }

      body {
        padding-top: 20px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 20px;
      }

      .chart-container {
        width: 100%;
        max-width: 1200px;
        max-height: 800px;
        margin: 0 auto;
      }

      .annotation {
        font-family: sans-serif;
      }

      rect.legend-mouseover-inactive,
      .legend-mouseover-inactive rect,
      .legend-mouseover-inactive path,
      .legend-mouseover-inactive circle,
      .legend-mouseover-inactive line,
      .legend-mouseover-inactive text.apexcharts-yaxis-title-text,
      .legend-mouseover-inactive text.apexcharts-yaxis-label {
        transition: 0.15s ease all;
        opacity: 0.1 !important;
      }

      .legend-mouseover-inactive .apexcharts-data-labels {
        opacity: 0 !important;
      }

      .apexcharts-toolbar-custom-icon {
        padding-top: 2px !important;
        padding-right: 4px !important;
        padding-left: 6px !important;
      }

      .chart-container.full-window {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        max-width: 100% !important;
        max-height: 100% !important;
        z-index: 9999;
        background-color: white;
        padding: 20px;
        box-sizing: border-box;
      }

      .noscroll {
        overflow: hidden;
      }

      #tab-bar {
        display: flex;
        gap: 0;
        padding: 0 10px;
        border-bottom: 2px solid #e0e0e0;
        margin-bottom: 12px;
      }

      .tab-btn {
        padding: 8px 20px;
        border: none;
        background: none;
        font-size: 14px;
        font-weight: 600;
        font-family: ui-sans-serif, system-ui, sans-serif;
        color: #666;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        margin-bottom: -2px;
        transition: color 0.15s, border-color 0.15s;
      }

      .tab-btn:hover {
        color: #333;
      }

      .tab-btn.active {
        color: #008FFB;
        border-bottom-color: #008FFB;
      }

      .chart-container.hidden-tab {
        display: none;
      }

      .chart-placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 400px;
        color: #888;
        font-size: 16px;
        font-family: sans-serif;
      }

      #ssid-filter {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding: 4px 10px 8px;
        align-items: center;
      }

      .ssid-chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 12px;
        background: #f0f0f0;
        font-size: 12px;
        font-family: ui-sans-serif, system-ui, sans-serif;
        cursor: pointer;
        user-select: none;
        transition: opacity 0.15s;
      }

      .ssid-chip.hidden {
        opacity: 0.4;
      }

      .ssid-chip input[type="checkbox"] {
        margin: 0;
        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <div id="tab-bar"></div>
    <div id="ssid-filter"></div>
    <div id="charts" style="display: flex; flex-wrap: wrap"></div>
    <script type="module">
      import ApexCharts from "apexcharts";

      const CHANNEL_NUMBER_MAX_24 = 16;
      const CHANNEL_NUMBER_MAX_5 = 170;
      const CHANNEL_NUMBER_MAX_6 = 233;

      let rawSeriesData = {};
      let displaySeriesData = {};
      let lastZoom = {};

      const colorMap = {};
      let colorIndex = 0;
      const COLOR_PALETTE = [
        '#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0',
        '#3F51B5', '#03A9F4', '#4CAF50', '#F9CE1D', '#FF6384',
        '#36A2EB', '#FFCE56', '#9966FF', '#FF9F40', '#C9CBCF',
        '#E91E63', '#9C27B0', '#00BCD4', '#8BC34A', '#FF5722',
        '#607D8B', '#795548', '#CDDC39', '#009688', '#673AB7',
        '#2196F3', '#FF9800', '#4DB6AC', '#BA68C8', '#AED581',
      ];

      let activeBand = null;
      const pendingCharts = {};
      const hiddenSSIDs = new Set();
      const knownSSIDs = new Set();

      const BAND_CONFIG = [
        { id: '24', name: '2.4GHz', maxChannel: CHANNEL_NUMBER_MAX_24 },
        { id: '5',  name: '5GHz',   maxChannel: CHANNEL_NUMBER_MAX_5 },
        { id: '6',  name: '6GHz',   maxChannel: CHANNEL_NUMBER_MAX_6 },
      ];

      function switchTab(bandId) {
        activeBand = bandId;
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.band === bandId);
        });
        document.querySelectorAll('.chart-container').forEach(el => {
          el.classList.toggle('hidden-tab', el.dataset.band !== bandId);
        });
        window.dispatchEvent(new Event('resize'));
      }

      function makeOptions(bandId, bandName, channels) {
        const options = {
          series: [],
          chart: {
            type: "area",
            redrawOnParentResize: true,
            height: "auto",
            width: "100%",
            zoom: {
              enabled: true,
              allowMouseWheelZoom: false,
              // autoScaleYaxis: false,
            },
            animations: {
              enabled: false,
            },
            events: {
              beforeResetZoom: (chart) => {
                lastZoom[bandName] = undefined;
                // chart.w.globals.lastXAxis.min = undefined;
                // chart.w.globals.lastXAxis.max = undefined;
                return true;
              },
              beforeZoom: (chart, { xaxis, yaxis }) => {
                let newXaxis = { ...xaxis };
                const minRange = 2;
                if (xaxis.max - xaxis.min < minRange) {
                  const mid = (xaxis.min + xaxis.max) / 2;
                  // desired +/-1 around midpoint to produce a minimum range of 2
                  const desiredMin = mid - 1;
                  const desiredMax = mid + 1;
                  let min = Math.max(channels[0], desiredMin);
                  let max = Math.min(channels[channels.length - 1], desiredMax);
                  // If clamping reduced the range below 2, try to expand the other side(s)
                  if (max - min < minRange) {
                    const deficit = minRange - (max - min);
                    // Prefer expanding lower bound first
                    min = Math.max(channels[0], min - deficit);
                    // If still not enough, expand the upper bound
                    if (max - min < minRange) {
                      const remaining = minRange - (max - min);
                      max = Math.min(
                        channels[channels.length - 1],
                        max + remaining,
                      );
                    }
                  }
                  newXaxis = { min, max };
                }
                return { xaxis: newXaxis, yaxis };
              },
              zoomed: (_chart, { xaxis, yaxis }) => {
                lastZoom[bandName] = [xaxis.min, xaxis.max];
                return true;
              },
              updated: (chart, options) => {
                if (
                  lastZoom[bandName] &&
                  (options.config.xaxis.min !== lastZoom[bandName][0] ||
                    options.config.xaxis.max !== lastZoom[bandName][1])
                ) {
                  // chart.updateOptions({
                  //   chart: {
                  //     animations: { dynamicAnimations: { enabled: false } },
                  //   },
                  // });
                  chart.zoomX(lastZoom[bandName][0], lastZoom[bandName][1]);
                  // chart.updateOptions({
                  //   chart: {
                  //     animations: { dynamicAnimations: { enabled: true } },
                  //   },
                  // });
                }
              },
            },
            toolbar: {
              tools: {
                // zoom: true,
                pan: false,
                zoomin: false,
                zoomout: false,
                reset:
                  '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M12 16v-2.5q0-.625.438-1.062T13.5 12H16v1.5h-2.5V16zm1.5 6q-.625 0-1.062-.437T12 20.5V18h1.5v2.5H16V22zm7-6v-2.5H18V12h2.5q.625 0 1.063.438T22 13.5V16zM18 22v-1.5h2.5V18H22v2.5q0 .625-.437 1.063T20.5 22zm2.775-12H18.7q-.65-2.2-2.475-3.6T12 5Q9.075 5 7.037 7.038T5 12q0 1.8.813 3.3T8 17.75V15h2v6H4v-2h2.35Q4.8 17.75 3.9 15.938T3 12q0-1.875.713-3.512t1.924-2.85t2.85-1.925T12 3q3.225 0 5.663 1.988T20.775 10"/></svg>',
                customIcons: [
                  {
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M20 8V6h-2q-.425 0-.712-.288T17 5t.288-.712T18 4h2q.825 0 1.413.588T22 6v2q0 .425-.288.713T21 9t-.712-.288T20 8M2 8V6q0-.825.588-1.412T4 4h2q.425 0 .713.288T7 5t-.288.713T6 6H4v2q0 .425-.288.713T3 9t-.712-.288T2 8m18 12h-2q-.425 0-.712-.288T17 19t.288-.712T18 18h2v-2q0-.425.288-.712T21 15t.713.288T22 16v2q0 .825-.587 1.413T20 20M4 20q-.825 0-1.412-.587T2 18v-2q0-.425.288-.712T3 15t.713.288T4 16v2h2q.425 0 .713.288T7 19t-.288.713T6 20zm2-6v-4q0-.825.588-1.412T8 8h8q.825 0 1.413.588T18 10v4q0 .825-.587 1.413T16 16H8q-.825 0-1.412-.587T6 14m2 0h8v-4H8zm0 0v-4z"/></svg>',
                    index: 2,
                    title: "Toggle Expand",
                    click: (chart, options, e) => {
                      const chartEl = chart.el;
                      if (
                        chartEl.parentElement.classList.contains("full-window")
                      ) {
                        options.config.chart.height = "auto";
                        chartEl.parentElement.classList.remove("full-window");
                        document.body.classList.remove("noscroll");
                      } else {
                        options.config.chart.height = "100%";
                        chartEl.parentElement.classList.add("full-window");
                        document.body.classList.add("noscroll");
                      }
                    },
                  },
                ],
              },
              export: {
                csv: {
                  filename: "export",
                  headerCategory: "channel",
                  headerValue: "rssi",
                },
                svg: {
                  filename: "export",
                },
                png: {
                  filename: "export",
                },
              },
            },
          },
          plotOptions: {
            area: {
              fillTo: "end",
            },
          },
          stroke: {
            width: 1,
            curve: "smooth",
          },
          legend: {
            showForSingleSeries: true,
            position: "left",
            onItemClick: {
              toggleDataSeries: false,
            },
            formatter: (seriesName, { seriesIndex, w }) => {
              const disp = displaySeriesData[bandId];
              if (!disp || !disp[seriesIndex]) return seriesName;
              const yValue = w.config.series[seriesIndex].data[1][1];
              const xValue = w.config.series[seriesIndex].data[1][0];
              let ssid = disp[seriesIndex].ssid;
              if (ssid === null) ssid = "n/a";
              const bssid = disp[seriesIndex].name;
              const bw = disp[seriesIndex].channelWidth;
              return [
                `Channel: ${xValue} RSSI: ${yValue}dBm BW: ${bw}MHz`,
                "<br>",
                ssid != "n/a"
                  ? `<b>${ssid}</b>`
                  : `<b style="color:#888;">${ssid}</b>`,
                "<br>",
                `<span style="font-size:0.9em;color:#888;">${bssid}</span>`,
              ];
            },
          },
          xaxis: {
            type: "numeric",
            min: channels[0],
            max: channels[channels.length - 1],
            tickAmount: Math.min(channels.length - 1, 15),
            labels: {
              rotate: false,
              hideOverlappingLabels: true,
              formatter: (val) => Math.round(val),
            },
            title: {
              text: "channel",
            },
            tooltip: {
              enabled: false,
            },
            crosshairs: {
              show: false,
            },
          },
          yaxis: {
            type: "numeric",
            min: -100,
            max: 0,
            title: {
              text: "dBm",
            },
            tooltip: {
              enabled: false,
            },
          },
          grid: {
            xaxis: {
              lines: {
                show: true,
              },
            },
          },
          dataLabels: {
            enabled: true,
            formatter: (val, { seriesIndex, dataPointIndex, w }) => {
              if (val === -100) return "";
              const disp = displaySeriesData[bandId];
              if (!disp || !disp[seriesIndex]) return "";
              const ssid = disp[seriesIndex].ssid;
              const ch = w.config.series[seriesIndex].data[1][0];
              const bw = disp[seriesIndex].channelWidth;
              const bwStr = bw ? ` ${bw}M` : "";
              if (ssid === null) return `${ch} n/a${bwStr}`;
              return `${ch} ${ssid}${bwStr}`;
            },
          },
          markers: {
            size: 0,
          },
          tooltip: {
            enabled: false,
            shared: false,
            intersect: false,
            // custom: () => '',
            marker: {
              show: false,
            },
            onDatasetHover: {
              highlightDataSeries: true,
            },
            x: {
              formatter: (
                value,
                { series, seriesIndex, dataPointIndex, w },
              ) => {
                return series[seriesIndex][1];
              },
            },
            y: {
              formatter: (
                value,
                { series, seriesIndex, dataPointIndex, w },
              ) => {
                return series[seriesIndex][1];
              },
            },
            // items: {
            //   display: 'none',
            // },
          },
          title: {
            text: bandName,
          },
          noData: {
            text: "Scanning...",
            align: "center",
            verticalAlign: "middle",
            style: {
              color: "#888",
              fontSize: "16px",
              fontFamily: "sans-serif",
            },
          },
        };
        return options;
      }

      function rebuildFilterPanel() {
        const panel = document.getElementById('ssid-filter');
        const currentSSIDs = new Set();
        for (const bandId of Object.keys(rawSeriesData)) {
          for (const s of rawSeriesData[bandId]) {
            currentSSIDs.add(s.ssid ?? 'n/a');
          }
        }
        for (const ssid of currentSSIDs) {
          if (knownSSIDs.has(ssid)) continue;
          knownSSIDs.add(ssid);
          const label = document.createElement('label');
          label.className = 'ssid-chip';
          label.dataset.ssid = ssid;
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !hiddenSSIDs.has(ssid);
          cb.addEventListener('change', () => {
            if (cb.checked) {
              hiddenSSIDs.delete(ssid);
              label.classList.remove('hidden');
            } else {
              hiddenSSIDs.add(ssid);
              label.classList.add('hidden');
            }
            for (const bid of Object.keys(rawSeriesData)) {
              applyFilter(bid);
            }
          });
          const span = document.createElement('span');
          span.textContent = ssid;
          label.appendChild(cb);
          label.appendChild(span);
          panel.appendChild(label);
        }
      }

      function applyFilter(bandId) {
        const chart = window[`chart${bandId}`];
        if (!chart || !rawSeriesData[bandId]) return;
        const filtered = rawSeriesData[bandId].filter(s => {
          const ssid = s.ssid ?? 'n/a';
          return !hiddenSSIDs.has(ssid);
        });
        displaySeriesData[bandId] = filtered;
        const colors = filtered.map(s => colorMap[s.name]);
        try {
          chart.w.config.colors = colors;
          chart.updateSeries(filtered);
        } catch (e) {
          console.error("Failed to apply filter", e);
        }
      }

      window.init = (bands) => {
        const tabBar = document.getElementById('tab-bar');
        const chartsDiv = document.getElementById('charts');
        let firstBand = null;

        for (const config of BAND_CONFIG) {
          const bandId = config.id;
          if (!bands[bandId]) continue;
          if (!firstBand) firstBand = bandId;

          const btn = document.createElement('button');
          btn.className = 'tab-btn';
          btn.dataset.band = bandId;
          btn.textContent = config.name;
          btn.addEventListener('click', () => switchTab(bandId));
          tabBar.appendChild(btn);

          const container = document.createElement('div');
          container.className = 'chart-container hidden-tab';
          container.dataset.band = bandId;
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart';
          chartDiv.id = `chart${bandId}`;
          container.appendChild(chartDiv);
          chartsDiv.appendChild(container);

          const placeholder = document.createElement('div');
          placeholder.className = 'chart-placeholder';
          placeholder.textContent = 'Scanning...';
          container.appendChild(placeholder);
          chartDiv.style.display = 'none';

          const channels = [...Array(config.maxChannel).keys()].map(v => v + 1);
          const options = makeOptions(bandId, config.name, channels);
          const chart = new ApexCharts(chartDiv, options);
          pendingCharts[bandId] = chart;
        }

        if (firstBand) switchTab(firstBand);
      };

      window.updateChart = (bandId, series) => {
        if (pendingCharts[bandId]) {
          if (series.length === 0) return;
          const chart = pendingCharts[bandId];
          const container = chart.el.parentElement;
          const placeholder = container.querySelector('.chart-placeholder');
          if (placeholder) placeholder.remove();
          chart.el.style.display = '';
          chart.render();
          window[`chart${bandId}`] = chart;
          delete pendingCharts[bandId];
        }
        if (window[`chart${bandId}`]) {
          const sorted = [...series].sort((a, b) => {
            const ssidA = a.ssid ?? '\uffff';
            const ssidB = b.ssid ?? '\uffff';
            if (ssidA !== ssidB) return ssidA.localeCompare(ssidB);
            return (a.name || '').localeCompare(b.name || '');
          });

          for (const s of sorted) {
            const bssid = s.name;
            if (!(bssid in colorMap)) {
              colorMap[bssid] = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
              colorIndex++;
            }
          }

          rawSeriesData[bandId] = sorted;
          rebuildFilterPanel();
          applyFilter(bandId);
        }
      };
    </script>
  </body>
</html>
